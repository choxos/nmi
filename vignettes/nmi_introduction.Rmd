---
title: "Introduction to Network Meta-Interpolation (NMI)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to Network Meta-Interpolation (NMI)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

# Network Meta-Interpolation (NMI)

Network Meta-Interpolation (NMI) is a method for addressing effect modification in network meta-analysis when combining individual patient data (IPD) and aggregate data (AgD). The method was developed by Harari et al. (2023) and allows for indirect treatment comparisons at specific covariate levels.

## Key Features

- **Handles effect modification**: Addresses differences in treatment effects across patient subgroups
- **Combines IPD and AgD**: Efficiently uses both individual and aggregate level data
- **Flexible modeling**: Supports binary, continuous, and count outcomes
- **Bayesian framework**: Uses Stan for robust statistical inference

## Installation

```{r eval=FALSE}
# Install from source
devtools::install_local("path/to/nmi")

# Load the package
library(nmi)
```

## Basic Usage

### Load Example Data

```{r eval=FALSE}
library(nmi)

# Load example datasets
IPD <- load_example_ipd()
AgD <- load_example_agd()

# Examine the data structure
head(IPD)
head(AgD)
```

### Basic NMI Analysis

```{r eval=FALSE}
# Define analysis parameters
x_vect <- c(0.675, 0.475)  # Effect modifier levels for comparison
AgD_EM_cols <- c('x1', 'x2')
IPD_EM_cols <- c('x1', 'x2')
Study_col <- 'Study'
samp_sizes <- rep(600, 6)  # Sample sizes for AgD studies
AgD_Trt_cols <- c('Trt1', 'Trt2')
TE_col <- 'TE'
SE_col <- 'se'
IPD_Trt_col <- 'Tr'
outcome_col <- 'Y'

# Perform NMI interpolation
NMI_result <- NMI_interpolation(
  IPD = IPD,
  AgD = AgD,
  x_vect = x_vect,
  AgD_EM_cols = AgD_EM_cols,
  IPD_EM_cols = IPD_EM_cols,
  Study_col = Study_col,
  samp_sizes = samp_sizes,
  AgD_Trt_cols = AgD_Trt_cols,
  TE_col = TE_col,
  SE_col = SE_col,
  IPD_Trt_col = IPD_Trt_col,
  outcome_col = outcome_col,
  outcome_type = "binary"
)

# View results
print(NMI_result$Final)
```

### Run Network Meta-Analysis

```{r eval=FALSE}
# Run NMA on interpolated data
NMI_fit <- NMA_run(
  dat = NMI_result$Final,
  N_chains = 3,
  N_iter = 1500,
  burnin = 500,
  outcome_type = "binary"
)

# Summarize results
NMI_summary <- NMA_NMI_summary(NMI_fit)
print(NMI_summary)
```

### Diagnostic Plots

```{r eval=FALSE}
# Create diagnostic plot
diagnostic_plot <- NMI_diagnostic_plot(NMI_result)
print(diagnostic_plot)

# Create interactive diagnostic plot
interactive_plot <- NMI_diagnostic_plotly(NMI_result)
interactive_plot
```

## Advanced Usage

### Multiple Outcome Types

The package supports three outcome types:

1. **Binary outcomes**: Uses logistic regression
2. **Continuous outcomes**: Uses linear regression  
3. **Count outcomes**: Uses Poisson regression

```{r eval=FALSE}
# For continuous outcomes
NMI_continuous <- NMI_interpolation(
  IPD = IPD_continuous,
  AgD = AgD_continuous,
  x_vect = x_vect,
  # ... other parameters
  outcome_type = "continuous"
)

# For count outcomes
NMI_count <- NMI_interpolation(
  IPD = IPD_count,
  AgD = AgD_count,
  x_vect = x_vect,
  # ... other parameters
  outcome_type = "count"
)
```

### Network Meta-Regression

```{r eval=FALSE}
# Run NMR with 2 effect modifiers
NMR_fit <- NMA_Meta_Reg_run_2D(
  dat = AgD_NMR,
  N_chains = 3,
  N_iter = 1500,
  burnin = 500
)

# Summarize at specific covariate levels
NMR_summary <- NMA_Metareg_summary_2D(NMR_fit, x_vect)
```

### Multilevel Network Meta-Regression

```{r eval=FALSE}
# Prepare data for ML-NMR
ML_NMR_data <- list(IPD = IPD, AgD = AgD_ML)

# Run ML-NMR
ML_NMR_fit <- ML_NMR_Run_2D(
  ML_NMR_data = ML_NMR_data,
  N_iter = 1500,
  N_chains = 3,
  burnin = 500,
  n_int = 500,
  outcome_type = "binary"
)

# Summarize results
ML_NMR_summary <- ML_NMR_summary_2D(
  n_trts = 4,
  ML_NMR_Fit = ML_NMR_fit,
  x_vect = x_vect
)
```

## Visualization

### Results Table

```{r eval=FALSE}
# Format results for display
results_table <- result_table(NMI_summary)
print(results_table)
```

### Forest Plot

```{r eval=FALSE}
# Compare multiple methods
forest_plot <- result_forest_plot(
  NMA_summary = NMA_summary,
  NMR_summary = NMR_summary,
  ML_NMR_summ = ML_NMR_summary,
  NMI_summary = NMI_summary
)
print(forest_plot)
```

### Results Table with Formatting

```{r eval=FALSE}
# Create formatted table
formatted_table <- display_result_table(
  NMA_results = result_table(NMA_summary),
  NMR_results = result_table(NMR_summary),
  ML_NMR_results = result_table(ML_NMR_summary),
  NMI_results = result_table(NMI_summary)
)
formatted_table
```

## Key Concepts

### Effect Modification

Effect modification occurs when the treatment effect varies across different patient subgroups. NMI addresses this by:

1. **Subgroup Analysis**: Breaking down IPD into subgroups based on effect modifiers
2. **Imputation**: Using BLUP to impute missing covariate values in AgD
3. **Interpolation**: Estimating treatment effects at desired covariate levels

### Best Linear Unbiased Predictor (BLUP)

BLUP is used to impute missing effect modifier values in the aggregate data by:

1. Estimating correlations between effect modifiers from IPD
2. Using these correlations to predict missing values in AgD
3. Accounting for uncertainty in the imputation process

### Bayesian Framework

All analyses use Bayesian methods implemented in Stan, providing:

- **Uncertainty quantification**: Full posterior distributions
- **Flexible modeling**: Easy to extend and modify
- **Robust inference**: Handles complex data structures

## References

Harari, O., Abrams, K. R., Ades, A. E., Sutton, A. J., & Cooper, N. J. (2023). Network meta‐interpolation: Effect modification adjustment in network meta‐analysis using subgroup analyses. *Journal of the Royal Statistical Society: Series A*, 186(2), 643-670.

## Getting Help

- Check the function documentation with `?function_name`
- Visit the package website for more examples
- Report issues on the GitHub repository